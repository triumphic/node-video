var startServer = function () {
    this.express = require('../public_nodejs/express');

    this.http = require('http');
    this.path = require('path');
    this.fs = require('fs');

    this.log4 = require('./log4logger');

    this.tempDirName = '_tempfile';     //文件上传的临时目录
    this.staticDirName = 'public';      //静态资源根目录
    this.viewDirName = 'views';         //视图文件夹名称
};

/*
 *服务端启动的方法
 *参数类型为object 提供的属性有：
 *port(非必须)  端口号，不传时从项目对应的config文件中获取
 *routes(必须) 当前项目的控制器(路由)
 *dirname(必须) 当前项目根目录所在的绝对位置
 *isLogin(默认false)  是否需要登录
 *startedCall  启动后的回调，非必须，无参数
 */
startServer.prototype.Start = startServer.prototype.start = function () {
    var _this = this;
    var arguObj = arguments[0];

    var port = arguObj.port;
    var routes = arguObj.routes;
    var dirname = arguObj.dirname;
    var isLogin = arguObj.isLogin || false;

    dirname = dirname.replace(/\\/g, '/');
    var uploadPath = this.path.resolve(dirname, './' + this.staticDirName + '/' + this.tempDirName).replace(/\\/g, '/');
    var staticPath = this.path.resolve(uploadPath, '../');

    global._baseDirname = dirname;

    var configInfo = require('./getConfig')() || {};
    port = port || configInfo.port;

    global._config = configInfo;
    global.commonLibUrl = configInfo.commonLibUrl;
    global._uploadPath = uploadPath;

    var app = this.express();
    app.set('port', port);
    app.set('views', dirname + '/' + this.viewDirName);
    app.engine('.html', require('../public_nodejs/ejs').__express);
    app.set('view engine', 'html');

    //log4js日志
    this.log4.CreateLog(app, dirname);

    app.use(this.express.bodyParser({ uploadDir: uploadPath }));
    app.use(this.express.methodOverride());
    app.use(this.express.cookieParser());

    //以redis存储session 保证session的健壮性 默认过期时间为一天或用户主动退出
    //if (isSession === true) {
    //    var sessionM = require("../public_nodejs/express-session");
    //    app.use(sessionM({
    //        secret: port.toString(),
    //        name: port.toString(),
    //        cookie: {
    //            httpOnly: true,
    //            maxAge: 1000 * 60 * 60 * 24
    //        }
    //    }));
    //}
    var fnMemoryStore = require('../public_nodejs/express-session/session/memory');
    var _memoryStore = new fnMemoryStore();
    global._memoryStore = _memoryStore;
    var sessionM = require("../public_nodejs/express-session");
    app.use(sessionM({
        secret: port.toString(),
        name: port.toString(),
        rolling: true,
        cookie: {
            httpOnly: true,
            maxAge: 1000 * 60 * 60 * 24
        },
        store: _memoryStore
    }));

    var ser = _this.http.createServer(app);
    ser.timeout = 1000 * 60 * 30;

    ser.listen(app.get('port'), function () {
        console.log('Express server listening on port ' + app.get('port'));
        require('./loadCommonLib')(function (loadErr) {
            if (!loadErr) {
                var mapFilePath = _this.path.join(dirname, pconst.mapFileName);
                if (_this.fs.existsSync(mapFilePath + '.js')) global._mapConfig = require(mapFilePath) || {};
                else global._mapConfig = {};
            }
            app.use(app.router);
            require('./publicRouter')(app, isLogin, _this.tempDirName);
            if (routes) {
                if (routes instanceof Array) {//具有多个路由文件,以数组的形式传入
                    for (var i = 0; i < routes.length; i++) {
                        routes[i](app);
                    }
                } else {//只有一个路由文件
                    routes(app);
                }
            }
            //静态目录，必须在路由声明之后设定
            app.use(_this.express.static(staticPath));
            if (typeof arguObj.startedCall == 'function') arguObj.startedCall();
        });
    });

    var childProcess = require('child_process');
    openChildProcess();
    function openChildProcess() {
        var attachmentOper = _this.path.resolve(__dirname, './attachmentOper');
        var cp = childProcess.fork(attachmentOper);
        cp.send({ uploadPath: _uploadPath });
        cp.on('exit', function (code, signal) {
            console.error('子进程退出,code:' + code + ',signal:' + signal);
            openChildProcess();
        });
    };
};

module.exports = new startServer();