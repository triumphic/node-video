function tool() {
    this.crypto = require('crypto');
    //系统编码，上传、下载时用
    this.systemCode = 'dataPlatform';
    //系统密钥，上传、下载时用
    this.systemSecret = '9e0891a7a8c8e885';
    //cookie中存放以此命名的属性，其值为sessionID
    this.ticketName = 'tk';
    //跳转到F时，url加上此参数代表项目ID
    this.projectIdName = 'pt';
    //系统中，加密时的密钥
    this.secretKey = 'persagy.com';
    //cookie中存放以此命名的属性，其值为登录时间
    this.loginTimeName = '_lt';
    this.userSessionName = 'puser';
    this.configServiceParName = '_configServiceName';
};
/*根据文件ID转成可用的下载链接*/
tool.prototype.toParseFileLink = function (fileId) {
    return fileId ? '/' + pconst.requestType.pdownload + '/' + psecret.create(fileId) : '';
};

/*解析后台返回的用户信息*/
tool.prototype.parserUser = function (user, req) {
    user = user || {};
    var newAuthorizations = [];
    var authorizations = user.authorizations || [];
    var userId = user.userId;
    if (!userId) return null;
    user.projects = user.projects || [];
    var newAuthors = [];
    var authorObj = {};
    for (var i = 0; i < authorizations.length; i++) {
        var curr = authorizations[i];
        /*不存在父级ID时，代表是F*/
        if (!curr.authorizationParentId) {
            curr.child = authorizations.filter(function (cu) {
                return cu.authorizationParentId == curr.authorizationId;
            });
            curr.virtualUrl = '/frame/' + curr.authorizationId;
            if (curr.functionUrl) {
                curr.functionUrl = curr.functionUrl.lastIndexOf('/') == curr.functionUrl.length - 1 ? curr.functionUrl : curr.functionUrl + '/';
                curr.functionUrl = curr.functionUrl + curr.authorizationId + '?';
                //需要选项目的F
                // if (curr.type == '2') {
                //     curr.functionUrl = curr.functionUrl + this.projectIdName + '='
                //         + (psecret.create((user.projects[0] || {}).projectId) || '');
                // }
            }
            if (curr.iconKey) curr.iconKey = this.toParseFileLink(curr.iconKey);
            newAuthorizations.push(curr);
        } else {
            authorObj[curr.authorizationId] = curr.authorizationId;
            newAuthors.push(curr);
        }
    }
    //导航F
    user.authorizations = newAuthorizations;
    //权限
    user.authors = newAuthors;
    user.authorObj = authorObj;
    //头像
    user.head_portrait = this.toParseFileLink(user.head_portrait);

    user.loginDevice = 'PC';
    return user;
};

/*解析数据结果*/
tool.prototype.parseResult = function (result, fn, demoDataObj) {
    var _this = this;
    var root = _mapConfig[fn];
    result = result || [];
    var count;
    var isPage = false;
    var firstItem = result[0] || {};
    firstItem.content ? (count = firstItem.count, result = firstItem.content, isPage = true) : '';
    if (!root) return isPage ? { count: count, content: result } : result;
    var dataTypeObj = pconst.mapDataType;
    var proArr = root.proArr || _mapConfig[root.proArrBy] || [];
    var sendResult = parse(root, result, fn);
    return isPage ? { count: count, content: sendResult } : sendResult;

    function parse(node, result, parentTableName, type) {
        result = result || [];
        type = type || node.type;
        if (type == dataTypeObj.tree.name) return constructorTree(result, node);
        var returnResult = [];
        var proArr = node.proArr || _mapConfig[node.proArrBy] || [];
        if (proArr.length == 0) {
            if (type == dataTypeObj.fileArray.name) {
                for (var i = 0; i < result.length; i++) {
                    var rtrt = result[i];
                    result[i] = rtrt ? _this.toParseFileLink(rtrt) : '';
                }
            }
            return type == dataTypeObj.object.name ? result[0] || {} : result;
        }
        if (!(result instanceof Array)) result = [result];
        for (var i = 0; i < result.length; i++) {
            var currRe = result[i];
            if (currRe == null) continue;
            var tempObj = {};
            for (var j = 0; j < proArr.length; j++) {
                var currPro = proArr[j];
                var reValue = currRe[currPro.mapName || currPro.name];
                var tempValue;
                switch (currPro.type) {
                    case dataTypeObj.boolean.name:
                        tempValue = reValue == true ? true : false;
                        break;
                    case dataTypeObj.number.name:
                        tempValue = Math.toFixed({
                            value: reValue,
                            fixedNum: currPro.fixed,
                            isByInt: currPro.fixedByInt,
                            isToSpecial: currPro.isToSpecial
                        });
                        break;
                    case dataTypeObj.string.name:
                        tempValue = currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : reValue || '';
                        break;
                    case dataTypeObj.date.name:
                        tempValue = reValue && currPro.format ? reValue.formatDate(currPro.format) :
                            reValue && !currPro.format ? reValue :
                                currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : '';
                        break;
                    case dataTypeObj.fileLink.name:
                        tempValue = reValue ? _this.toParseFileLink(reValue) : '';
                        break;
                    case dataTypeObj.object.name:
                    case dataTypeObj.array.name:
                    case dataTypeObj.fileArray.name:
                        tempValue = arguments.callee(currPro, reValue);
                        break;
                    case dataTypeObj.tree.name:
                        tempValue = constructorTree(reValue, currPro);
                        break;
                }
                tempObj[currPro.name] = tempValue;
            }
            returnResult.push(tempObj);
        }
        return type == dataTypeObj.object.name ? returnResult[0] || {} : returnResult;
    };

    function constructorTree(maxArr, currPro) {
        if (!maxArr || maxArr.length == 0) return [];
        //找寻第一级，第一级的父级id在数组内肯定不存在对应的
        var rootArr = [];
        var rootParentId;
        for (var i = 0; i < maxArr.length; i++) {
            rootArr = maxArr.filter(function (a) {
                return a[currPro.mapParentIdTo] == maxArr[i][currPro.mapParentId];
            });
            if (rootArr.length == 0) {
                rootParentId = maxArr[i][currPro.mapParentId];
                break;
            }
        }
        return find(rootParentId, maxArr, 1);

        //客户端需要的树，要求返回的数据必须是平铺的树
        function find(parentId, arr, level) {
            var returnArr = [];
            for (var j = 0; j < arr.length; j++) {
                var curr = arr[j];
                var currParentId = curr[currPro.mapParentId];
                if (currParentId != parentId) continue;

                var returnObj = parse(currPro, [curr], null, dataTypeObj.object.name);
                if (!returnObj.id) returnObj.id = curr[currPro.mapParentIdTo];
                if (!returnObj.parentId)
                    returnObj.parentId = curr[currPro.mapParentId];
                returnObj.level = level;
                //arr.splice(j, 1);
                returnObj.child = arguments.callee(returnObj.id, arr, level + 1);
                returnArr.push(returnObj);
                //--j;
            }
            return returnArr;
        };
    };
};


/*解析数据结果*/
tool.prototype.parseResultForEquie = function (result, fn, demoDataObj, count) {
    var _this = this;
    var root = _mapConfig[fn];
    var isPage = count || count === 0 ? true : false;
    if (!root) return isPage ? { data: result, count: count } : result[0] || {};
    var dataTypeObj = pconst.mapDataType;
    var proArr = root.proArr || _mapConfig[root.proArrBy] || [];
    if (proArr.length == 0) {
        return isPage ? { data: result, count: count } : result[0] || {};
    }
    var sendResult = parse(root, result, fn);
    var returnResult = isPage ? {
        data: sendResult,
        count: count
    } : sendResult;
    return returnResult;

    function parse(node, result, parentTableName, type) {
        result = result || [];
        type = type || node.type;
        if (type == dataTypeObj.tree.name) return constructorTree(result, node);
        var returnResult = [];
        var proArr = node.proArr || _mapConfig[node.proArrBy] || [];
        if (proArr.length == 0) {
            if (type == dataTypeObj.fileArray.name) {
                for (var i = 0; i < result.length; i++) {
                    var rtrt = result[i];
                    result[i] = _this.toParseFileLink(rtrt);
                }
            }
            return type == dataTypeObj.object.name ? result[0] || {} : result;
        }

        if (!(result instanceof Array)) result = [result];
        for (var i = 0; i < result.length; i++) {
            var currRe = result[i];
            if (currRe == null) continue;
            var tempObj = {};
            for (var j = 0; j < proArr.length; j++) {
                var currPro = proArr[j];
                var reValue = currRe[currPro.mapName || currPro.name];
                var tempValue;
                switch (currPro.type) {
                    case dataTypeObj.boolean.name:
                        tempValue = reValue == true ? true : false;
                        break;
                    case dataTypeObj.number.name:
                        tempValue = Math.toFixed({
                            value: reValue,
                            fixedNum: currPro.fixed,
                            isByInt: currPro.fixedByInt,
                            isToSpecial: currPro.isToSpecial
                        });
                        break;
                    case dataTypeObj.string.name:
                        tempValue = currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : reValue || '';
                        break;
                    case dataTypeObj.date.name:
                        tempValue = reValue && currPro.format ? reValue.formatDate(currPro.format) :
                            reValue && !currPro.format ? reValue :
                                currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : '';
                        break;
                    case dataTypeObj.fileLink.name:
                        tempValue = _this.toParseFileLink(reValue);
                        break;
                    case dataTypeObj.object.name:
                        tempValue = arguments.callee(currPro, reValue);
                        break;
                    case dataTypeObj.array.name:
                        tempValue = arguments.callee(currPro, reValue);
                        break;
                    case dataTypeObj.fileArray.name:
                        tempValue = arguments.callee(currPro, reValue);
                        break;
                    case dataTypeObj.tree.name:
                        tempValue = currPro.type == dataTypeObj.tree.name ? constructorTree(reValue, currPro) :
                            arguments.callee(currPro, reValue);
                        break;
                }
                tempObj[currPro.name] = tempValue;
            }
            returnResult.push(tempObj);
        }
        return type == dataTypeObj.object.name ? returnResult[0] || {} : returnResult;
    };

    function constructorTree(maxArr, currPro) {
        if (!maxArr || maxArr.length == 0) return [];
        //找寻第一级，第一级的父级id在数组内肯定不存在对应的
        var rootArr = [];
        var rootParentId;
        for (var i = 0; i < maxArr.length; i++) {
            rootArr = maxArr.filter(function (a) {
                return a[currPro.mapParentIdTo] == maxArr[i][currPro.mapParentId];
            });
            if (rootArr.length == 0) {
                rootParentId = maxArr[i][currPro.mapParentId];
                break;
            }
        }
        return find(rootParentId, maxArr, 1);

        //客户端需要的树，要求返回的数据必须是平铺的树
        function find(parentId, arr, level) {
            var returnArr = [];
            for (var j = 0; j < arr.length; j++) {
                var curr = arr[j];
                var currParentId = curr[currPro.mapParentId];
                if (currParentId != parentId) continue;

                var returnObj = parse(currPro, [curr], null, dataTypeObj.object.name);
                if (!returnObj.id) returnObj.id = curr[currPro.mapParentIdTo];
                if (!returnObj.parentId)
                    returnObj.parentId = curr[currPro.mapParentId];
                returnObj.level = level;
                //arr.splice(j, 1);
                returnObj.child = arguments.callee(returnObj.id, arr, level + 1);
                returnArr.push(returnObj);
                //--j;
            }
            return returnArr;
        };
    };
};

/*把类似字符串 a=1&b=2 转成键值对形式，{a:1,b:2}
*originalStr   原始字符串
*isDecipher    是否解密，默认true，为true时将对每一个键的值用decipherFn进行解密
*decipherFn    解密的方法，必须为接收一个字符串并返回一个字符串的方法，默认为psecret.parser
*/
tool.prototype.urlParamToObj = function (originalStr, isDecipher, decipherFn) {
    if (!originalStr) return {};
    isDecipher = isDecipher === false ? false : true;
    var newObj = {};
    var paramArr = originalStr.split('&');
    for (var i = 0; i < paramArr.length; i++) {
        var ppArr = paramArr[i].split('=');
        var val = ppArr[1];
        if (isDecipher) {
            val = typeof decipherFn == 'function' ? decipherFn(val) : psecret.parser(val);
        }
        newObj[ppArr[0]] = val;
    }
    return newObj;
};

/*把object对象转成 a=1&b=2 字符串的形式
*originalObj    原始object
*isCipher       是否加密，默认true，为true时将对每一个键的值用cipherFn进行加密
*cipherFn       加密的方法，必须为接收一个字符串并返回一个字符串的方法，默认为psecret.create
*/
tool.prototype.objToUrlParam = function (originalObj, isCipher, cipherFn) {
    var arr = [];
    isCipher = isCipher === false ? false : true;
    for (var proName in originalObj) {
        if (originalObj.hasOwnProperty(proName) == false) continue;
        var val = originalObj[proName];
        if (isCipher) {
            val = typeof cipherFn == 'function' ? cipherFn(val) : psecret.create(val);
        }
        arr.push(proName + '=' + val);
    }
    return arr.join('&');
};

/*加密*/
tool.prototype.cipher = function (data) {
    if (data == null || data === '') return false;
    var cipher = this.crypto.createCipher('aes-256-cbc', this.secretKey);
    var crypted = cipher.update(data.toString(), 'utf8', 'hex');
    crypted += cipher.final('hex');
    return crypted;
};

/*解密*/
tool.prototype.decipher = function (data) {
    if (data == null || data === '') return false;
    var decipher = this.crypto.createDecipher('aes-256-cbc', this.secretKey);
    var dec = decipher.update(data, 'hex', 'utf8');
    dec += decipher.final('utf8');
    return dec;
};

/*构造服务url*/
tool.prototype.constructorServiceUrl = function (objParam) {
    var configServiceName = objParam[this.configServiceParName];
    var url = objParam.url || (configServiceName ? _config[configServiceName] : _config.serviceUrl);
    url = (url.lastIndexOf('/') == url.length - 1 ? url : url + '/');
    var fn = objParam.fn || '';
    fn = fn.indexOf('/') === 0 ? fn.substring(1) : fn;
    return url + fn;
};

module.exports = new tool();